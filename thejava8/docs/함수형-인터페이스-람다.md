# 함수형 인터페이스와 람다

## 함수형 인터페이스와 람다 표현식 소개

- `interface` 클래스에, *추상 메서드가 단 하나* 만 있으면 이를 **함수형 인터페이스**라 부른다
- 만약에 추상 메서드가 두개가 있다면 --> 함수형 인터페이스가 아니다!
- 또한 정의되는 추상 메서드에는 기본적으로 abstract 선언자가 있는 것.
  `abstract void doIt()` == `void doIt()`
- static method도 정의할 수 있음
- default method도 정의할 수 있음.

> 즉 인터페이스에서 정의할 수 있는 메서드가 다양해졌음. 

```java
package com.inflearn.thejava;

@FunctionalInterface 
public interface RunSomething {

  void doIt(); // 추상 메서드

  static void printName() { //static method
    System.out.println("Name");
  }

  default void printAge() { //default method
    System.out.println("29");
  }

}
```

- 만약 위와 같은 인터페이스도 함수형 인터페이스라 부를 수 있을까?

  - OK

  - 왜?

    - 추상 메서드(abstract method)가 단 한 개 있기 때문이다.

    - 즉 static, default 메서드 존재 유무가 함수형 인터페이스 인지 아닌지를 결정하진 않는다.

- `@FunctionalInterface`
  - `java`에서 기본적으로 제공해주기 때문에, 아무것도 `import` 되지 않는다.
  - 해당 에노테이션을 추가한 다음에, 인터페이스 클래스를 좀 더 견고하게 관리하는 것을 추천함.
  - 왜?
    - 해당 어노테이션이 있을 시, 추상 메서드가 2개라면 **컴파일 오류** 를 발생시킨다.
    - 즉 컴파일 단계에서 미리 오류를 잡아줄 수 있기 때문에 유용하다는 의미일듯.



```java
package com.inflearn.thejava;

public class Foo {

  public static void main(String[] args) {
    //익명 내부 클래스 anonymous inner class
    RunSomething runSomething = new RunSomething() {
      @Override
      public void doIt() {
        System.out.println("Hello");
      }
    };
  }
}

```

- 이 전에는 인터페이스를 익명 내부 클래스 형태로 사용할 수 있었음.

```java
package com.inflearn.thejava;

public class Foo {

  public static void main(String[] args) {
    //익명 내부 클래스 anonymous inner class
    RunSomething runSomething = () -> System.out.println("Hello");
  }
}

```

- 위와 같이 바꿔줄 수 있다.
- 람다형식으로!
  - 코드를 많이 줄일 수 있다.
  - 내부적으로 동일하지만, 줄여 쓸 수 있다는 장점이 있음.

- `() -> System.out.println("Hello");` , 이렇게 작성했지만 **특수한 객체 타입**이라고 보면됨.

- 다시 말하면, 위와 같은 형태를 재활용하거나, 특정 메서드의 파라미터로 활용하는 것 이 가능하다.

- 즉 First class object로 사용할 수 있다.

  - 함수를 파라미터로 받던가, 함수로 리턴하는 것이 가능함.

- 고차 함수 (High-Order Function)

  - 함수가 함수를 매개변수로 받을 수 있고, 함수를 리턴할 수도 있다.

- 순수 함수 (Pure Function)

  - 수학적인 함수

  - 입력받은 값이 동일한 경우, 결과가 같아야한다.

  - 만약에 입력값이 동일한데, 결과가 다를 여지가 있다면?

    ```java
    	//int baseNumber = 10;//함수 외부
    RunSomething runSomething = new RunSomething() {
          int baseNumber = 10;//함수 외부
          @Override
          public int doIt(int number) {
            baseNumber++; //2번
            return number + baseNumber; //1번
          }
        };
    ```

    1. 함수 내부에서, 함수 외부에 있는 어떤 상태값을 가지고 있는 경우
    2. 함수 내부에서, 외부에 있는 어떤 값을 변경하려고 하는 경우

    - 기본적으로 함수 내부에서 사용하고 있는 외부 변수는 `final`이라고 가정하고 사용한다.





## 자바에서 제공하는 함수형 인터페이스