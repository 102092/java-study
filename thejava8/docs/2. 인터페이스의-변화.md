# 1. 인터페이스 기본 메소드와 스택틱 메소드

- 어떤 인터페이스를 여러 클래스에서 구현하고 있다고 가정할 때,

- 해당 인터페이스에 추상 메서드가 추가되면, 모든 클래스에 컴파일 에러가 발생함.

- 그래서 `default method` 가 등장하였음.

  - 내가 구현한 인터페이스에만 추가할 수 있음.
  - 이미 정의되어있는 Library에는 안됨.

  ```java
  public interface Foo {
  
    void printName();
  	
   	/**
     * @implSpec 이 구현체는 getName()으로 가져온 문자를 대문자로 바꿔 출력한다.
     */
    default void printNameUppercase() {
      System.out.println(getName().toUpperCase());
    }
  
    String getName();
  
  }
  ```

- 그런데 문제는, 인터페이스에 정의한 대로 동작할 것이라고 예상할 수 없음.
  - 만약에 `getName()` 이 null이 들어온다면?? --> 에러 발생할듯
- 그래서 **문서화**를 잘 해놓는 것이 중요하다.
- 또는 문제가 된다면, 이 인터페이스를 구현하는 쪽에서 **재정의** 할 수도 있다.
- `Object` 에서 제공하는 메소드들은 <u>인터페이스에서 재정의할 수 없다.</u>
  - equals, hashcode, toString....



```java
public interface Bar extends Foo{

  void printNameUppercase();

}
```

- `Foo` 인터페이스에서 default로 제공되는 인터페이스를 `Bar` 에서는 사용하고 싶지 않다면, 추상 메소드로 위와 같이 재구현해야함.
- 이렇게 할 경우, `Bar` 인터페이스를 구현하는 클래스들은 , `printNameUppercase()` 를 모두 구현해야됨.



```java
public class DefaultFoo implements Foo, Bar{
  String name;

  public DefaultFoo(String name) {
    this.name = name;
  }

  @Override
  public void printName() {
    System.out.println(this.name);
  }

  @Override //충돌하는 default method를 재정의하게 되었음.
  public void printNameUppercase() {
    
  }

  @Override
  public String getName() {
    return this.name;
  }
}

```

- `Foo`, `Bar` 인터페이스 동일하게 `printNameUppercase()` 가 있다고 가정하고, `DefaultFoo ` 가 두 개의 인터페이스를 구현한다고 생각해보자
- 2개의 동일한 default method가 있기에 --> 결국 충돌하게 될듯(컴파일 오류)
- Java는 어떤 메서드를 구현해야할 지 모르기 때문에
- 해당 클래스에서 재정의 하게 된다.



```java
public interface Foo {
  static void printAnything(){
    System.out.println("wow");
  }
}


public class App {

  public static void main(String[] args) {
    Foo.printAnything(); //"wow"
  }
}


```

- 유틸리티 메소드를 제공할 때, 인터페이스에서 static method를 제공할 수 있음.

