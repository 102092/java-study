# 1. Java Concurrent 

- Concurrent Software

  - 동시에 여러 작업을 할 수 있는 소프트 웨어
  - 예) 웹 브라우저로 유투브를 보면서 키보드로 문서에 타이핑을 할 수 있음.

- Concurrent Programming for Java

  - 멀티 프로세싱 (ProcessBuilder)
  - 멀티 쓰레드

  

## Java Multi Thread

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      System.out.println(Thread.currentThread().getName()); //Main Thread
  }
}

```

- main thread 에서 다른 스레드를 만들 수 있다.

1. Thread를 확장해서 만드는 방법

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      MyThread myThread = new MyThread();
      myThread.start();
      System.out.println("Hello: "+ Thread.currentThread().getName());
  }

  static class MyThread extends Thread { //자신의 스레드를 만드는 방법
      @Override
      public void run() {
          System.out.println("Thread: " + Thread.currentThread().getName());
      }
  }
}

```

- 코드 흐름으로 볼 때, MyThread에서 Thead: ... 가 먼저 프린트 되고, Hello: ... 가 나올 것으로 보이지만, Hello가 먼저 찍히기도 한다.
- 즉 쓰레드는 어떤 것이 먼저 실행될 지 순서를 보장하지 못한다.

2. Runnable을 익명 클래스로 주는 방법

```java
package com.inflearn.thejava;

public class App {

    public static void main(String[] args) {
        Thread thread = new Thread(() -> { //java8부터 lambda를 이용하여.. 쉽게 표현
            System.out.println("Thread: " + Thread.currentThread().getName());
        });
        thread.start();

        System.out.println("Hello: " + Thread.currentThread().getName());
    }
}
```

- Thread sleep
  - 스레드를 잠시 재운다.
  - 재우면? 다른 스레드에게 우선권이 갈 듯.
  - 즉 해당 스레드가 꺠어날 때까지 기다리진 않음.



- Thead interrupt
  - 잠자고 있던 스레드를 깨우는 방법



- Thread join

  - 다른 스레드를 기다린다.

  ```java
  package com.inflearn.thejava;
  
  public class App {
  
      public static void main(String[] args) throws InterruptedException {
          Thread thread = new Thread(() -> {
              try {
                  Thread.sleep(3000L); //1초간 Thread를 잠재운다.
              } catch (InterruptedException e) {
                  throw new IllegalStateException(e);
              }
  
          });
          thread.start();
          System.out.println("Hello: " + Thread.currentThread().getName());
          thread.join(); //main thread가 thread-0이 3초후 끝날 때 까지 기다렸다가, 진행된다
          System.out.println(thread + "is finished");
      }
  }
  ```

  

### 문제점

- 스레드가 2개만 되어도 sleep, join, interrupted 상태를 적용시키는 것이 어렵다.
- 즉 개발자가 정확히 알고 다루기가 힘들다.
- 그래서 `Executors`가 등장



# 2. Executors

