# 1. Java Concurrent 

- Concurrent Software

  - 동시에 여러 작업을 할 수 있는 소프트 웨어
  - 예) 웹 브라우저로 유투브를 보면서 키보드로 문서에 타이핑을 할 수 있음.

- Concurrent Programming for Java

  - 멀티 프로세싱 (ProcessBuilder)
  - 멀티 쓰레드

  

## Java Multi Thread

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      System.out.println(Thread.currentThread().getName()); //Main Thread
  }
}

```

- main thread 에서 다른 스레드를 만들 수 있다.

1. Thread를 확장해서 만드는 방법

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      MyThread myThread = new MyThread();
      myThread.start();
      System.out.println("Hello: "+ Thread.currentThread().getName());
  }

  static class MyThread extends Thread { //자신의 스레드를 만드는 방법
      @Override
      public void run() {
          System.out.println("Thread: " + Thread.currentThread().getName());
      }
  }
}

```

- 코드 흐름으로 볼 때, MyThread에서 Thead: ... 가 먼저 프린트 되고, Hello: ... 가 나올 것으로 보이지만, Hello가 먼저 찍히기도 한다.
- 즉 쓰레드는 어떤 것이 먼저 실행될 지 순서를 보장하지 못한다.

2. Runnable을 익명 클래스로 주는 방법

```java
package com.inflearn.thejava;

public class App {

    public static void main(String[] args) {
        Thread thread = new Thread(() -> { //java8부터 lambda를 이용하여.. 쉽게 표현
            System.out.println("Thread: " + Thread.currentThread().getName());
        });
        thread.start();

        System.out.println("Hello: " + Thread.currentThread().getName());
    }
}
```

- Thread sleep
  - 스레드를 잠시 재운다.
  - 재우면? 다른 스레드에게 우선권이 갈 듯.
  - 즉 해당 스레드가 꺠어날 때까지 기다리진 않음.



- Thead interrupt
  - 잠자고 있던 스레드를 깨우는 방법



- Thread join

  - 다른 스레드를 기다린다.

  ```java
  package com.inflearn.thejava;
  
  public class App {
  
      public static void main(String[] args) throws InterruptedException {
          Thread thread = new Thread(() -> {
              try {
                  Thread.sleep(3000L); //1초간 Thread를 잠재운다.
              } catch (InterruptedException e) {
                  throw new IllegalStateException(e);
              }
  
          });
          thread.start();
          System.out.println("Hello: " + Thread.currentThread().getName());
          thread.join(); //main thread가 thread-0이 3초후 끝날 때 까지 기다렸다가, 진행된다
          System.out.println(thread + "is finished");
      }
  }
  ```

  

### 문제점

- 스레드가 2개만 되어도 sleep, join, interrupted 상태를 적용시키는 것이 어렵다.
- 즉 개발자가 정확히 알고 다루기가 힘들다.
- 그래서 `Executors`가 등장



# 2. Executors

- Executor를 직접 사용할 일은 거의 없음.

- 대부분 ExecutorService를 사용

  - ScheduledExecutorService : 주기적으로 뭔가 실행해야 되는 일이 있을 때 사용한다.

- ExecutorServcie는 작업이 끝나도, 다음 작업을 위해 대기하고 있기 때문에 프로세스가 죽질 않는다. 

  - 그러므로 코드를 실행하면, 명시적으로 shutdown을 해줘야한다.

  - `shutdown()`은 graceful shutdown임.
    - graceful shutdown? 현재 진행 중인 작업은 마치고, service를 죽이는 것.

  - `now()` : 현재 작업이 진행 되든지 말든지, 그냥 serivce 죽여버림.

- `Executors.newFixedThreadPool(2);` : ThreadPool에 2개의 Thread를 만드는 것.

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  public class App {
  
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newFixedThreadPool(2);
          executorService.submit(getRunner("apple"));
          executorService.submit(getRunner("banana"));
          executorService.submit(getRunner("grape"));
          executorService.submit(getRunner("tap"));
          executorService.submit(getRunner("water"));
          executorService.submit(getRunner("fuck"));
  
          executorService.shutdown();
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple +": "+ Thread.currentThread().getName());
      }
  }
  //apple: pool-1-thread-1
  //banana: pool-1-thread-2
  //grape: pool-1-thread-1
  //tap: pool-1-thread-1
  //water: pool-1-thread-2
  //fuck: pool-1-thread-1
  ```

  

- `ScheduledExecutorService`

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.Executors;
  import java.util.concurrent.ScheduledExecutorService;
  import java.util.concurrent.TimeUnit;
  
  public class App {
  
      public static void main(String[] args) {
          ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
          executorService.schedule(getRunner("apple"), 3, TimeUnit.SECONDS); //3초정도 기다리고 실행하라
          executorService.shutdown();
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple + ": " + Thread.currentThread().getName());
      }
  }
  
  ```

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.Executors;
  import java.util.concurrent.ScheduledExecutorService;
  import java.util.concurrent.TimeUnit;
  
  public class App {
  
      public static void main(String[] args) {
          ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
          executorService.scheduleAtFixedRate(getRunner("apple"), 1,2, TimeUnit.SECONDS); //1초 기다렸다가, 2초마다 실행하라
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple + ": " + Thread.currentThread().getName());
      }
  }
  ```

  - 해당 코드 아래  `executorService.shutdown(); ` 가 있으면 해당 코드가 interruped 받아, 종료됨.



### Fork/Join

- 멀티 프로세싱 기반으로 프로그래밍 할 때 좋은 Executor의 구현체



### callable

- Runnable이랑 같은데, 무언가를 return할 수 있다는 점이 다르다.
- 이러한 받아올 수 있는 return값이  `Future` 이다.



