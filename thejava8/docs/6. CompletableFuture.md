# 1. Java Concurrent 

- Concurrent Software

  - 동시에 여러 작업을 할 수 있는 소프트 웨어
  - 예) 웹 브라우저로 유투브를 보면서 키보드로 문서에 타이핑을 할 수 있음.

- Concurrent Programming for Java

  - 멀티 프로세싱 (ProcessBuilder)
  - 멀티 쓰레드

  

## Java Multi Thread

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      System.out.println(Thread.currentThread().getName()); //Main Thread
  }
}

```

- main thread 에서 다른 스레드를 만들 수 있다.

1. Thread를 확장해서 만드는 방법

```java
package com.inflearn.thejava;

public class App {

  public static void main(String[] args) {
      MyThread myThread = new MyThread();
      myThread.start();
      System.out.println("Hello: "+ Thread.currentThread().getName());
  }

  static class MyThread extends Thread { //자신의 스레드를 만드는 방법
      @Override
      public void run() {
          System.out.println("Thread: " + Thread.currentThread().getName());
      }
  }
}

```

- 코드 흐름으로 볼 때, MyThread에서 Thead: ... 가 먼저 프린트 되고, Hello: ... 가 나올 것으로 보이지만, Hello가 먼저 찍히기도 한다.
- 즉 쓰레드는 어떤 것이 먼저 실행될 지 순서를 보장하지 못한다.

2. Runnable을 익명 클래스로 주는 방법

```java
package com.inflearn.thejava;

public class App {

    public static void main(String[] args) {
        Thread thread = new Thread(() -> { //java8부터 lambda를 이용하여.. 쉽게 표현
            System.out.println("Thread: " + Thread.currentThread().getName());
        });
        thread.start();

        System.out.println("Hello: " + Thread.currentThread().getName());
    }
}
```

- Thread sleep
  - 스레드를 잠시 재운다.
  - 재우면? 다른 스레드에게 우선권이 갈 듯.
  - 즉 해당 스레드가 꺠어날 때까지 기다리진 않음.



- Thead interrupt
  - 잠자고 있던 스레드를 깨우는 방법



- Thread join

  - 다른 스레드를 기다린다.

  ```java
  package com.inflearn.thejava;
  
  public class App {
  
      public static void main(String[] args) throws InterruptedException {
          Thread thread = new Thread(() -> {
              try {
                  Thread.sleep(3000L); //1초간 Thread를 잠재운다.
              } catch (InterruptedException e) {
                  throw new IllegalStateException(e);
              }
  
          });
          thread.start();
          System.out.println("Hello: " + Thread.currentThread().getName());
          thread.join(); //main thread가 thread-0이 3초후 끝날 때 까지 기다렸다가, 진행된다
          System.out.println(thread + "is finished");
      }
  }
  ```

  

### 문제점

- 스레드가 2개만 되어도 sleep, join, interrupted 상태를 적용시키는 것이 어렵다.
- 즉 개발자가 정확히 알고 다루기가 힘들다.
- 그래서 `Executors`가 등장



# 2. Executors

- Executor를 직접 사용할 일은 거의 없음.

- 대부분 ExecutorService를 사용

  - ScheduledExecutorService : 주기적으로 뭔가 실행해야 되는 일이 있을 때 사용한다.

- ExecutorServcie는 작업이 끝나도, 다음 작업을 위해 대기하고 있기 때문에 프로세스가 죽질 않는다. 

  - 그러므로 코드를 실행하면, 명시적으로 shutdown을 해줘야한다.

  - `shutdown()`은 graceful shutdown임.
    - graceful shutdown? 현재 진행 중인 작업은 마치고, service를 죽이는 것.

  - `now()` : 현재 작업이 진행 되든지 말든지, 그냥 serivce 죽여버림.

- `Executors.newFixedThreadPool(2);` : ThreadPool에 2개의 Thread를 만드는 것.

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  public class App {
  
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newFixedThreadPool(2);
          executorService.submit(getRunner("apple"));
          executorService.submit(getRunner("banana"));
          executorService.submit(getRunner("grape"));
          executorService.submit(getRunner("tap"));
          executorService.submit(getRunner("water"));
          executorService.submit(getRunner("fuck"));
  
          executorService.shutdown();
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple +": "+ Thread.currentThread().getName());
      }
  }
  //apple: pool-1-thread-1
  //banana: pool-1-thread-2
  //grape: pool-1-thread-1
  //tap: pool-1-thread-1
  //water: pool-1-thread-2
  //fuck: pool-1-thread-1
  ```

  

- `ScheduledExecutorService`

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.Executors;
  import java.util.concurrent.ScheduledExecutorService;
  import java.util.concurrent.TimeUnit;
  
  public class App {
  
      public static void main(String[] args) {
          ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
          executorService.schedule(getRunner("apple"), 3, TimeUnit.SECONDS); //3초정도 기다리고 실행하라
          executorService.shutdown();
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple + ": " + Thread.currentThread().getName());
      }
  }
  
  ```

  ```java
  package com.inflearn.thejava;
  
  import java.util.concurrent.Executors;
  import java.util.concurrent.ScheduledExecutorService;
  import java.util.concurrent.TimeUnit;
  
  public class App {
  
      public static void main(String[] args) {
          ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
          executorService.scheduleAtFixedRate(getRunner("apple"), 1,2, TimeUnit.SECONDS); //1초 기다렸다가, 2초마다 실행하라
      }
  
      private static Runnable getRunner(String apple) {
          return () -> System.out.println(apple + ": " + Thread.currentThread().getName());
      }
  }
  ```

  - 해당 코드 아래  `executorService.shutdown(); ` 가 있으면 해당 코드가 interruped 받아, 종료됨.



## Fork/Join

- 멀티 프로세싱 기반으로 프로그래밍 할 때 좋은 Executor의 구현체



## callable

- Runnable이랑 같은데, 무언가를 return할 수 있다는 점이 다르다.
- 이러한 받아올 수 있는 return값이  `Future` 이다.



# 3. Callable, Future

- Callable
  - Runnable과 비슷한 데, 딱 하나 다른 것이 있다면 return값을 받을 수 있음.

- Future

  - isDone() : Future에 해당하는 작업이 끝났으면 true, 아직 안 끝났으면 false를 리턴한다. 현재 여기서는 아직 안 끝났으므로 false가 나옴

  - cancel(true) : 현재 작업을 interrupted 해서 강제 종료

  - cancel(false) : 현재 작업이 끝날 때 까지 기다렸다가 종료

    - cancel을 하면 작업(future) get을 통해 가져올 수 없다.

  - 예제 코드

    ```java
    package com.inflearn.thejava;
    
    import java.util.concurrent.*;
    
    public class App {
    
        public static void main(String[] args) throws ExecutionException, InterruptedException {
            ExecutorService executorService = Executors.newSingleThreadExecutor();
    
            Callable<String> hello = () -> {
                Thread.sleep(5000L);
                return "Hello";
            };
    
            Future<String> helloFuture = executorService.submit(hello);
            System.out.println("Started"); //get이전까지는 코드가 안 기다리고 실행된다.
            System.out.println(helloFuture.isDone()); //isDone() 은 끝났으면 true, 아직 안 끝났으면 false를 리턴한다. 현재 여기서는 아직 안 끝났으므로 false가 나옴
    
            helloFuture.cancel(false); //그러나 get을 만난 순간 멈춘다. 결과값을 가져올 때 까지 기다린다. blocking call
    
            System.out.println(helloFuture.isDone()); //여기서는 true return
            System.out.println("End");
            executorService.shutdown();
        }
    }
    ```



- InvokingAll

  ```java
  package com.inflearn.thejava;
  
  import java.util.Arrays;
  import java.util.List;
  import java.util.concurrent.*;
  
  public class App {
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          ExecutorService executorService = Executors.newSingleThreadExecutor();
  
          Callable<String> hello = () -> {
              Thread.sleep(2000L);
              return "Hello";
          };
  
          Callable<String> java = () -> {
              Thread.sleep(3000L);
              return "Hello";
          };
  
          Callable<String> keesun = () -> {
              Thread.sleep(1000L);
              return "Hello";
          };
  
          List<Future<String>> futures = executorService.invokeAll(Arrays.asList(hello, java, keesun)); //blocking call, 바로 결과가 나옴. 즉 모든 결과를 모은다
          for (Future<String> f : futures) {
              System.out.println(f.get());
          }
          executorService.shutdown();
      }
  }
  ```

- InvokAny

  ```java
  package com.inflearn.thejava;
  
  import java.util.Arrays;
  import java.util.List;
  import java.util.concurrent.*;
  
  public class App {
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          ExecutorService executorService = Executors.newFixedThreadPool(3);
  
          Callable<String> hello = () -> {
              Thread.sleep(2000L);
              return "hello";
          };
  
          Callable<String> java = () -> {
              Thread.sleep(3000L);
              return "java";
          };
  
          Callable<String> keesun = () -> {
              Thread.sleep(1000L);
              return "keesun";
          };
  
          String s = executorService.invokeAny(Arrays.asList(hello, java, keesun)); //blocking call, 바로 결과가 나옴.
          System.out.println(s);
          executorService.shutdown();
      }
  }
  ```

  