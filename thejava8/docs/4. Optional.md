# 1. Optional 소개

- 기본적으로 Optional 전 null 처리는 `if` 문을 통해서 해결했었음.

- 문제점은, 이 부분의 체크를 잊을 수 있음.

- 그래서 종종 `NullPointException` 을 만나게 된다.

- 문제점은, `Null` 을 리턴하는 것 자체가 문제다.

- 혹은

  ```java
  public Progress getProgress() {
    if (this.progress == null) {
      throw new IllegalException(); //runtime exception...
    }
    return progress;
  }
  ```

  1. CheckedException을 던지기 시작하면, 에러 처리를 강제하는 문제점이 생기고

  2. 에러가 발생하면, java는 stack trace를 찍는 데, 이 자체로 resource를 사용하기 때문에, 진짜로 필요하는 경우에만 에러를 처리하도록 해야한다.

- 비어있는 값이 전달 될 수 있는 경우에, `Optional` 로 감싸서 리턴을 할 수 가 있음.
  - `Null` 을 Optional이라는 박스 안에 넣어서 전달하는 방식임.
- Optional은 <u>리턴 타입에만 쓰는 것</u>만이 권장사항임.
- `Optioanl.ofNullable(T)`   :  T는 **Null이 들어올 수 있음**을 가정한다.
- `Optional.of(T)` : T는 **Null이 아님**을 가정한다.
  - Null이 들어오면 NullPointException이 발생한다.



## 주의할 것

### 파라미터

```java
public void setProgress(Optional<Progress> progress) {
	progress.ifPresent(p -> this.progress = p);
}
```

- `setProgress(null)` 을 할 경우에 --> NullPointException 발생
- Optional을 사용한 의미가 없다.
- 결국에는 해당 메서드 내부에, Null을 체크하는 로직이 있어야한다.

```java
public void setProgress(Optional<Progress> progress) {
  if(progess != null) {
			progress.ifPresent(p -> this.progress = p);    
  }
}
```

### map의 key type

- map의 가장 큰 특징은 key는 null일 수가 없음을 보장하는 것.
- 그런데 그 key값이 비어일수도 있다? --> 굉장히 안 좋은 방법



### 도메인 클래스 멤버변수

- 노 권장
- 설계의 문제일 가능성이 높다.



### Primitive type 

- `Optional.of(10)` 
  - 이 자체로 Boxing, UnBoxing이 발생한다.
  - 즉 성능상으로 문제가 발생함.
- 그러므로, `OptionalInt...` 을 사용하자



### Optional을 리턴하는 메서드에서 null을 리턴하면 안됨

- 정 리턴할 것이 없으면 `Optional.Empty()` 를 사용하라



### Collection, Maps, Stream, Arrays, Optional은 Optional로 감싸지 말 것





# 2. Optional API

