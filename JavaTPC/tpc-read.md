## 자바 구동방식 JVM

1. 123.java 파일 생성

2. class file(1차 컴파일, byte Code화) 바로 실행할 수 없음.

3. 그럼 별도로 이 클래스 파일 실행해주는 엔진이 필요함 -> JVM(java virtual machine)을 통해서 2차 컴파일
   - 구동될 OS 환경에 맞게 ! 재 컴파일 되는 과정.
4. 123.exe 로 바뀜 code와 같이 실행될 수 있도록 바뀜.
   - 실행은 누가함?
     - JVM이라는 프로세스에 통해서 

![image-20191004231136016](tpc-read.assets/image-20191004231136016.png)

- 해당 운영체제 맞는 JDK를 설치
  - 메모리 위에 JVM가 탑재 되어있음. 놀고 있지. 
  - 그러다가 실행명령어 123.exe가 오면 메모리에 올려서 실행함.

- 여러 운영체제가 있는 만큼 , 특정 운영체제에 종속되도록 컴파일 하면 안되겠지.
- 그래서 class file을 만들고(공통적으로,byte코드로)
- 실행하라는 명령이 떨어지면, 위 class 파일을 가져가서, JVM이 해당 운영체제에 맞게 2차 컴파일을 함.
- 그러면 다른 언어에 비해서는 **속도가 좀 느리겠네**?

- JAVA를 실행하기 위해서는 **JRE가 필요하다. 개발 환경이 아닌 구동환경**을 위해서



## 변수,자료형 할당

- 변수를 선언한다. 기억공간에 해당 변수에 해당하는 바를 기록한다.
  - 고려해야할 사안은?
    1. 크기
    2. 종류
- `int a,b,c`
  1. 크기 **4 byte**
  2. 종류 **int** 형
- int 자료형, a 변수, = 할당 연산자

- 자료형

  - **변수의 크기**와 **변수에 저장될 데이터의 종류**를 결정하는 것

  ![1570542502970](tpc-read.assets/1570542502970.png)

  - 컴파일러에서 <u>기본으로 제공</u>해주는 자료형

  

- **사용자 정의 자료형**

  ![1570542532468](tpc-read.assets/1570542532468.png)

  - 객체 지향 프로그래밍의 시작점.



- 변수 선언

  - 변수 선언? 메모리에 변수를 만드는 것.

    ![1570543010827](tpc-read.assets/1570543010827.png)

- 할당

  - 할당을 해야 변수가 데이터가 저장된다.



### 변수, 배열

- 배열

  - 변수를 연속적으로 만드는 방법
  - **객체 **object로 취급함.. `new` 를 통해 생성해야함. 
  - 동일한 타입의 데이터를 여러개 저장하기 위한 메모리 구조
    - 서로 다른 타입 데이터를 저장하지 못함.

- 2차원 배열

  ![image-20191112210502752](tpc-read.assets/image-20191112210502752.png)

  - 메모리에는 연속적으로 배열이 만들어지지만,
  - 우리가 이해하는 방식은 행렬방식으로 이해하는게 편할듯.
  - 3행 4열, 총 12개 3개의 가로, 4개의 세로 
    - 즉 1차원 배열이 여러개 있음.



### 변수, 메서드

![image-20191112211233270](tpc-read.assets/image-20191112211233270.png)

- 유사성을 찾아 볼 수 는 있지만, 현재까지 느껴봤을 때는 내가 알던 대로 이해한 대로만 알고있는게 좋을듯.



### Call by Value, Reference

![image-20191112214035490](tpc-read.assets/image-20191112214035490.png)

- 메서드의 매개변수 전달기법은 5가지 정도 있음.

- 메서드가 호출이 되려면,

  1. 실인수와 가인수의 갯수가 같아야 하고,
  2. 데이터 타입이 같아야 한다.

  - 즉 매개변수 숫자가 같아야 하고, 그러한 입력된 변수가 설정된 매개변수와 같은 데이터 타입이어야 한다.

- Call by Value
  
  - 값을 전달하는 기법
- Call by Reference 
  - 번지를 전달하는 기법
  - 생성된 메모리 공간을 공유한다.



### JVM Memory Model 2

![image-20191112215223129](tpc-read.assets/image-20191112215223129.png)

![image-20191112215242828](tpc-read.assets/image-20191112215242828.png)

- JVM이 사용하는 4가지 메모리 영역이 있음. 
  
  - method, stack, heap, literal
  
- stack : FILO

- Main method는 static 키워드가 반드시 있어야, 메모리에 먼저 로딩이 됨.

- PC : program counter , 현재 프로그램이 실행되고 있는 포인터

- **static** keyword

  - 프로그램을 실행전에, method Area 에 로딩을 미리 시키기 위한 키워드

  - 그럼 static 을 안쓸때 어떻게 할까?

    - 어떻게 메모리 위에 올릴까?

    ![image-20191112221244081](tpc-read.assets/image-20191112221244081.png)
  
- `TPC80 TPC= new TPC08();`

  - new~ 객체 생성을 통해 heap 메모리 올라갈 장소가 생긴다.
  - 그리고 그 안에 관련된 메서드 기계어 코드가 올라온다.
  - 그런데 메서드는 Method Area 올라오기 때문에
  - add는 Method Area 중 non-static zone에 add 기계어 코드가 올라오고
  - heap Area add 공간은, Method Area - non-static zone - add를 pointer 하고 있는 방식으로 진행된다.

- add는 TPC 객체에서 가르키고 있기 때문에, `TPC.add()` 를 통해 호출한다.

### 기본자료형, 사용자 정의 자료형

- 기본자료형 ? 정수, 실수, 문자.
- 사용자 정의 자료형 ? 

- 새로운 자료형을 만드려면, 

  1. `Class` 로 정의해야함.

  2. 그리고 메모리에 올려야하고(객체를 생성해야하고)

  3. 어떻게? 생성자 메서드를 통해서 

     ```java
     BookDTO = new BookDTO();
     ```

  4. 그래서 클래스를 정의하면, 기본적으로 이러한 객체를 생성하는 <u>생성자 메서드</u> 가 포함되어있음.

  ```java
  public BookDTO(){
      super(); //생략되어있음. 제거해도 자동으로 들어가있으니까.
  }
  //이런식으로 생성자 메서드가 있음. 
  ```

  - default 생성자.
  - 이게 있어야만, <u>메모리에 객체를 생성</u>할 수 있음.

- 객체가 만들어지면, `this` 라는 것이 stack Area에 만들어짐. 이건 자기 자신을 가르키는 객체

- Package ? 폴더 개념



### 객체 생성과정

![image-20191113023255778](tpc-read.assets/image-20191113023255778.png)

- VO? Value Object
- Class, 청사진

- 메모리에 객체가 생성되는 동시에, `this` 라는 자기 자신을 가르키는 객체도 생성된다.

- 도트 연산자를 통해, 객체 속성에 **직접적으로 접근하는 방법은 위험한 방법**



### 생성자 메서드

![image-20191113024318035](tpc-read.assets/image-20191113024318035.png)

- 생성자 메서드는 **클래스 이름**과  동일함.
- 생성자 메서드는 **return 타입이 없음**.

- 생성자의 역할, 객체를 초기화 한다.
  - 객체를 초기화 하기 전에는, 객체가 생성되어 있어야 한다.

- 오버라이딩(중복정의 **Overloading**)
  - 메서드의 이름이 같지만, 매개변수의 갯수가 다르거나, 매개변수의 타입이 다르거나
  - 자바에서는 이런 함수들을 각각 다르게 판단한다.

- heap memory : new 연산자를 통해 객체가 생성될때 올라가는 메모리

### 

### Private 생성자

![image-20191113030810775](tpc-read.assets/image-20191113030810775.png)

- **인스턴스 메서드** : 반드시 new 키워드를 통해 객체 생성후에 접근가능한 메서드
- static 멤버인 경우, new 키워드를 통한 객체 생성이 필요 없음.
  - 그럴 경우, 해당 객체의 생성자 메서드는 private으로 만들어줘서 불필요한 객체생성을 막아주면 좋음

- System. --> static, Math... -->Static 왜? 자주 사용하니까



### class, object, instance

![image-20191113032736492](tpc-read.assets/image-20191113032736492.png)

- 정확하게 구분할 필요는 없지만..
- 객체. 객체 타입 + 변수 상태이면 object라 부르고
- 이 object가 구체적인 객체를 가르키면, 이러한 것은 object라 부르지 않고, 인스턴스 변수라 부르게 됨.
- 인스턴스가 만들어져야, 데이터를 넣고 뺄 수 있음.
- 전체적으로 인스턴스를 만드는 과정이라 일컫을 수 있음.



### 잘 설계된 클래스

- 정보 은닉

![image-20191113034828178](tpc-read.assets/image-20191113034828178.png)

