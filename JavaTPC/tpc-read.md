## 자바 구동방식 JVM

1. 123.java 파일 생성

2. class file(1차 컴파일, byte Code화) 바로 실행할 수 없음.

3. 그럼 별도로 이 클래스 파일 실행해주는 엔진이 필요함 -> JVM(java virtual machine)을 통해서 2차 컴파일
   - 구동될 OS 환경에 맞게 ! 재 컴파일 되는 과정.
4. 123.exe 로 바뀜 code와 같이 실행될 수 있도록 바뀜.
   - 실행은 누가함?
     - JVM이라는 프로세스에 통해서 

![image-20191004231136016](tpc-read.assets/image-20191004231136016.png)

- 해당 운영체제 맞는 JDK를 설치
  - 메모리 위에 JVM가 탑재 되어있음. 놀고 있지. 
  - 그러다가 실행명령어 123.exe가 오면 메모리에 올려서 실행함.

- 여러 운영체제가 있는 만큼 , 특정 운영체제에 종속되도록 컴파일 하면 안되겠지.
- 그래서 class file을 만들고(공통적으로,byte코드로)
- 실행하라는 명령이 떨어지면, 위 class 파일을 가져가서, JVM이 해당 운영체제에 맞게 2차 컴파일을 함.
- 그러면 다른 언어에 비해서는 **속도가 좀 느리겠네**?

- JAVA를 실행하기 위해서는 **JRE가 필요하다. 개발 환경이 아닌 구동환경**을 위해서



## 변수,자료형 할당

- 변수를 선언한다. 기억공간에 해당 변수에 해당하는 바를 기록한다.
  - 고려해야할 사안은?
    1. 크기
    2. 종류
- `int a,b,c`
  1. 크기 **4 byte**
  2. 종류 **int** 형
- int 자료형, a 변수, = 할당 연산자

- 자료형

  - **변수의 크기**와 **변수에 저장될 데이터의 종류**를 결정하는 것

  ![1570542502970](tpc-read.assets/1570542502970.png)

  - 컴파일러에서 <u>기본으로 제공</u>해주는 자료형

  

- **사용자 정의 자료형**

  ![1570542532468](tpc-read.assets/1570542532468.png)

  - 객체 지향 프로그래밍의 시작점.



- 변수 선언

  - 변수 선언? 메모리에 변수를 만드는 것.

    ![1570543010827](tpc-read.assets/1570543010827.png)

- 할당

  - 할당을 해야 변수가 데이터가 저장된다.



### 변수, 배열

- 배열

  - 변수를 연속적으로 만드는 방법
  - **객체 **object로 취급함.. `new` 를 통해 생성해야함. 
  - 동일한 타입의 데이터를 여러개 저장하기 위한 메모리 구조
    - 서로 다른 타입 데이터를 저장하지 못함.

- 2차원 배열

  ![image-20191112210502752](tpc-read.assets/image-20191112210502752.png)

  - 메모리에는 연속적으로 배열이 만들어지지만,
  - 우리가 이해하는 방식은 행렬방식으로 이해하는게 편할듯.
  - 3행 4열, 총 12개 3개의 가로, 4개의 세로 
    - 즉 1차원 배열이 여러개 있음.



### 변수, 메서드

![image-20191112211233270](tpc-read.assets/image-20191112211233270.png)

- 유사성을 찾아 볼 수 는 있지만, 현재까지 느껴봤을 때는 내가 알던 대로 이해한 대로만 알고있는게 좋을듯.



### Call by Value, Reference

![image-20191112214035490](tpc-read.assets/image-20191112214035490.png)

- 메서드의 매개변수 전달기법은 5가지 정도 있음.

- 메서드가 호출이 되려면,

  1. 실인수와 가인수의 갯수가 같아야 하고,
  2. 데이터 타입이 같아야 한다.

  - 즉 매개변수 숫자가 같아야 하고, 그러한 입력된 변수가 설정된 매개변수와 같은 데이터 타입이어야 한다.

- Call by Value
  
  - 값을 전달하는 기법
- Call by Reference 
  - 번지를 전달하는 기법
  - 생성된 메모리 공간을 공유한다.



### JVM Memory Model 2

![image-20191112215223129](tpc-read.assets/image-20191112215223129.png)

![image-20191112215242828](tpc-read.assets/image-20191112215242828.png)

- JVM이 사용하는 4가지 메모리 영역이 있음. 
  
  - method, stack, heap, literal
  
- stack : FILO

- Main method는 static 키워드가 반드시 있어야, 메모리에 먼저 로딩이 됨.

- PC : program counter , 현재 프로그램이 실행되고 있는 포인터

- **static** keyword

  - 프로그램을 실행전에, method Area 에 로딩을 미리 시키기 위한 키워드

  - 그럼 static 을 안쓸때 어떻게 할까?

    - 어떻게 메모리 위에 올릴까?

    ![image-20191112221244081](tpc-read.assets/image-20191112221244081.png)
  
- `TPC80 TPC= new TPC08();`

  - new~ 객체 생성을 통해 heap 메모리 올라갈 장소가 생긴다.
  - 그리고 그 안에 관련된 메서드 기계어 코드가 올라온다.
  - 그런데 메서드는 Method Area 올라오기 때문에
  - add는 Method Area 중 non-static zone에 add 기계어 코드가 올라오고
  - heap Area add 공간은, Method Area - non-static zone - add를 pointer 하고 있는 방식으로 진행된다.

- add는 TPC 객체에서 가르키고 있기 때문에, `TPC.add()` 를 통해 호출한다.

### 기본자료형, 사용자 정의 자료형

- 기본자료형 ? 정수, 실수, 문자.
- 사용자 정의 자료형 ? 