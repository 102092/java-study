# 1. 코드 커버리지는 어떻게 측정할까?

- 코드 커버리지 툴(Java coco) : 테스트 코드가, 내 소스코드 작동을 얼마나 커버하는 가?
- 어떻게 동작할까?
  - Bytecode 읽어서, 코드 커버리지를 챙겨야하는 부분을 다 센 다음에,
  - 테스트 코드가 실행될 때, 얼마정도 위에 챙겨야하는 부분을 지나갔는 지 확인함.
  - 그러면 코드 커버리지를 알 수 있다.

- 포인트는 바이트 코드 조작과 관련있음!
- 어느 정도 코드 커버리지를 충족하지 못하면 빌드를 실패하도록 만들 수도 있음.



# 2. 마술

- 바이트 코드를 조작하는 데 쓰이는 라이브러리 
  - ASM (고전적이고, 가장 널리 쓰인다.)
  - javassist
  - ByteBuddy
- ByteBuddy를 통해, 기존에 있는 클래스 파일을 바꿔 끼워 놓고, 
- 다시 실행하면 토끼가 나온다.



# 3. Javaagent 

- 클래스가 올라갈 때(클래스 로딩될 때) 바이트 코드가 바뀐다.
- 클래스로더가 클래스를 읽어올 때 javaagent를 통해서 바이트 코드가 바뀐다(VM Option jar)를 통해서..



# 4. 바이트코드 조작 툴 활용 예

1. 프로그램 분석
   - 코드에서 버그 찾는 툴.
   - 코드의 복잡도를 계산하는 툴
2. 클래스 파일 생성
   - **프록시 생성**
     - AOP
     - Hibernate Lazy Loading
     - Mock
   - 특정 API 호출 접근제한 한다던가.. 바이트 코드를 조작해서 특정 조건을 만족할 때만 해당 로직을 호출할 수 있도록..
   - **스칼라 언어의 컴파일러** , 컴파일시에 바이트코드를 생성함으로써 JVM위에서 돌아갈 수 있도록 한다.
3. 그외
   - 프로파일러, 애플리케이션이 메모리를 얼마나 쓰는지, 스레드가 몇개인지.. 그런 것을 알아보는 툴.
     - newrelic
   - 최적화
   - 로깅...
4. 스프링
   - Compoent Scan :  ASM을 사용해서, 컴포넌트 스캔을 할 대상을 찾아낸다.
     - 해당 위치 부터, 하위 패키지까지 뒤져가면서 Compoent Scan을 할 대상을 찾아낸다
     - 찾아서, Bean으로 등록해줌
     - 찾는 과정이 ASM을 이용함
     - `ClassPathSacnningCadidateComponetProvider` 
       - 어떤 타임에 메타 데이터를 읽어온다.
       - 메타 리더는, 클래스 리더등을 사용해서 클래스에 붙어있는 어노테이션을 불러온다.
       - 즉 결국에는 코드를 분석해서, ByteCode를 파악해서 자신이 등록할 클래스인지 아닌지 판단한다.

- 학습할 주제
  - ASM
  - Javassist
  - ByteBuddy
  - CGlib