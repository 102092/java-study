# 1. 클래스 정보 조회

- 리플렉션은 `Class<T> ` 를 이용하면 된다.

- 클래스를 로딩하면, JVM중 heap 영역에들어간다.

- 클래스 타입의 인스턴스를 가져오는 방법? (클래스 정보를 가져오는 방법?)

  ```java
  Class<Book> bookClass = Book.class;
  ```

  또는...

  ```java
  Book book = new Book();
  Class<? extends Book> aClass = book.getClass();
  ```

  또는

  ```java
  Class.forName("해당 클래스가 있는 package");
  ```

- 리플렉션으로는 접근지시자 같은 거 무시하고, 클래스 정보를 가져올 수 있다.
- `getDeclaredFields()` : 해당 클래스의 선언된 모든 변수들을 가져온다(접근제어자 상관없이)



# 2. 에노테이션

- 기본적으로 주석과 같은 취급

- 바이트 코드를 로딩 했을 때, 애노테이션 정보는 빼고 로딩한다.

  - 만약에 메모리에 같이 로딩하고 싶으면.. 해당 에노테이션에 선언해줘야함

  ```java
  @Retention(RetentionPolicy.Runtime) //런타임시에 올리겠다는 뜻
  public @Interface MyAnnotation {
    
  }
  ```

- target

  ```java
  @Retention(RetentionPolicy.Runtime)
  @Target({ElementType.Type, ElementType.FIELD}) //이 에노테이션을 Type과 FIELD에서만 사용하겠다라는 의미, 어길경우 컴파일 단계에서 잡아준다.
  public @Interface MyAnnotation {
    
    String name() default "name"; // 기본 값을 선언하는 방법
    
    Integer number() default 100;
    
  }
  ```

- 상속

  ```java
  @Retention(RetentionPolicy.Runtime)
  @Target({ElementType.Type, ElementType.FIELD})
  @Inherited // 이 애노테이션은 상속 받아서도 사용할 수 있음.
  public @Interface MyAnnotation {
    
    String name() default "name";
    
    Integer number() default 100;
    
  }
  ```

- 특정 에노테이션이 들어이있는 필드도 찾을 수 있고, 그 필드에 접근할 수 도 있음.