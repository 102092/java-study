# 10.  equals는 일반 규약을 지켜 재정의하라

## 아래 정의된 상황 중 하나라면, `equals` 는 재정의하지 않는 것이 최선!

1. 각 인스턴스가 본질적으로 고유할 경우 
   - 예 : `Thread`
2. 인스턴스의 논리적 동치성을 검사할 필요성이 없다.
   - `java.util.regex.Pattern`은 `equals` 를 재정의하여, `Pattern` 들의 인스턴가 같은 정규표현식을 나타내고 있는지 확인한다.
   - 즉 각 인스턴스가 고유한 주소를 가지고 있지는 않지만, 나타내고자 하는바가 동일한지 확인한다는 의미인듯.
3. 상위 클래스에서 재정의한 `equals` 가 하위 클래스에도 딱 들어맞는 경우
   - `Set` 구현체인 `AbstractSet`이 구현한 `equals`  상속받아서 사용하고 있음. 
   - 즉 재정의할 필요가 없음!
4. 클래스가 `private` 이거나, `package-private` 이고 (패키지가 숨겨져 있고) `equals` 메서드를 호출할 일이 없을 때
   - 실수라도 `equals`  가 호출되는 일을 막고 싶을 때!

## 언제 `equals` 를 재정의 해야할까?

- 객체 끼리 물리적(주소) 가 같은지 확인이 필요할 때가 아닌, <u>논리적인 동치성</u>을 확인해야할 때
  - 주로 VO(Value Object) 들이 이에 해당한다.
  - 다만 VO라고 하더라도, 값이 같은 인스턴스가 2개 이상 만들어지지 않음이 보장된다면, `equals` 를 재정의하지 않아도 됨.



### 일반규약

> equals 메서드는 동치관계를 구현하며 아래를 만족한다.

- 반사성 : null이 아닌 모든 참조값 x 에 대해 x.equals(x) 는 true
- 대칭성 : null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 는 true, y.equals(x) 도 true
- 추이성 : null이 아닌 모든 참조값 x,y,z에 대해 x.equals(y) 가 true, y.equals(z) 도 true이면, x.equals(z) 는 true 이다
- 일관성 : null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 를 반복해서 호출하면 항상 true or false를 반환.
- null - 아님 : null이 아닌 모든 참조값 x 에 대해 x.equals(null) 은 false. 



#### 반사성

- 객체는 자기 자신과 같아야 함.
  - 이걸 만족하지 않는 객체가 있을까..?



#### 대칭성

```java
public final class CaseInsensitiveString(){
    private final String s;

    public CaseInsensitiveString(String s){
        this.s = Objects.requireNonNull(s);
    }
    //equalsIgnoreCase은 대소문자 구별없이 문자열 equals 검사
  
    @Override 
  	public boolean equals(Object o) {
        if (o instance of CaseInsensitiveString) //CaseInsensitiveString 인스턴스라면,
            return s.equalsIgnoreCase( //대소문자 구별없이 같은지 보아라
          ((CaseInsensitiveString) o).s);
     		if(o instanceof String) //String의 인스턴스라면, 
            return s.equalsIgnoreCase((String) o); // casting하여 대소문자 구별없이 비교
        return false;
    }
 	// 나머지 
}

CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish";

cis.equals(s) == true; 
s.equals(cis) == false; // 대칭성을 위반했음.
//왜? String의 equals는 CaseInsensitiveString를 모르고 있기에,구별이 안된다.
```

- `equals` 를 아래와 같이 바꿔줘야함

```java
@Override
public boolean equals(Object o) {
  return o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgonreCase(s);
  //비교할수 있는 인스턴스는 CaseInsensitiveString이어야하고, 대소문자를 제외하고 비교해봐야한다.
}
```



#### 추이성

- 삼단 논법과 비슷한듯.

```java
class Point {
  private final int x;
  private final int y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  @Override
  public boolean equals(Object o) {
    if(!(o instanceof Point)) return false;
    Point p = (Point) o;
    return this.x == p.x && this.y == p.y;
  }
}

class ColorPoint extends Point {
  
  private final Color color;

 .... //equals를 구현하지 않을 경우, 상속 되어 Color를 무시한 채 equals를 사용하게 된다. --> 좋지 않음
}
```



##### 대칭성을 위반한 경우

```java
class ColorPoint extends Point {
  
  private final Color color;

  @Override
  public boolean equals(Object o) {
    if(!(o instanceof ColorPoint)) return false;
    
    return super.equals(o) && this.color == ((ColorPoint) o).color;
  }
}

ColorPoint a = new ColorPoint(1, 2, Color.RED);
Point b = new Point(1, 2);

System.out.println(a.equals(b)); //false Point 객체가 이니므로 false
System.out.println(b.equals(a)); //true 좌표만 비교하므로 true , 
// 서로 비교했을 경우 다르므로 --> 대칭성이 위반된다.
```



##### 추이성을 위반한 경우

```java
class ColorPoint extends Point {
  
  private final Color color;

  @Override
  public boolean equals(Object o) {
    if(!(o instanceof Point)) return false;

    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.
    if(!(o instanceof ColorPoint)) return o.equals(this);
    
    //o가 ColorPoint이면 색상까지 비교한다.
    return super.equals(o) && this.color == ((ColorPoint) o).color;
  }
}

ColorPoint a = new ColorPoint(1, 2, Color.RED);
Point b = new Point(1, 2);
ColorPoint c = new ColorPoint(1, 2, Color.BLUE);

System.out.println(a.equals(b)); //true
System.out.println(b.equals(c)); //true --> 대칭성은 지켜줬음
System.out.println(a.equals(c)); //false --> 그렇지만 추이성은 지켜주지 않았음
```

- a==b 이고 b==c이면, a==c 이어야하지만, 위의 재정의된 `equals` 는 이를 보장해주지 못했다.

  

##### 무한 재귀에 빠질 위험도 있음.

```java
class SmellPoint extends Point {
  
  private final Smell smell;

  @Override
  public boolean equals(Object o) {
    if(!(o instanceof Point)) return false;

    //o가 일반 Point이면 색상을 무시햐고 x,y정보만 비교한다.
    if(!(o instanceof SmellPoint)) return o.equals(this);
    
    //o가 ColorPoint이면 색상까지 비교한다.
    return super.equals(o) && this.smell == ((SmellPoint) o).smell;
  }
}

Point cp = new ColorPoint(1, 2, Color.RED);
Point sp = new SmellPoint(1, 2, Smell.SWEET);

System.out.println(cp.equals(sp)); //StackOverFlowError
```

1. CodePoint 의 equals가 실행됨
   - `if(!(o instanceof ColorPoint)) return o.equals(this);` 여기에 걸린다
2. SmellPoint 의 equals가 실행된다
   - `if(!(o instanceof SmellPoint)) return o.equals(this);` 에 걸림
3. 1번으로...2번으로 왔다갔다.??? -->StackOverFlow



> 결로적으로 클래스를 확장해나가면서 equals를 만족시킬만한 방법은 존재하지 않음.



##### 리스코프 치환 원칙 위배

- 리스코프 치환 원칙이란?
  - <u>자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.</u>
- 다시 말하자면, 부모클래스에서는 수행가능한데, 자식 클래스는 수행하지 못한다? 이러면 리스코프 치환원칙을 위배한 것이라 말할 수 있음.

```java
class Point {
  
  private final int x;
  private final int y;
	
  // 단위 원 안이 모든 점을 포함하도록 unitCircle을 초기화 한다.
  private static final Set<Point> unitCircle = Set.of(new Point(0, -1),
   new Point(0, 1),
   new Point(-1, 0),
   new Point(1, 0)
  );
		
  //Point가 원안에 있는가?
  public static boolean onUnitCircle(Point p) {
    return unitCircle.contains(p);
  }

  @Override
  public boolean equals(Object o) {
    if(o == null || o.getClass() != this.getClass()) { 
      //o.getClass == ColorPoint.Class
      //this.getClass == Point.Class 
      return false;
    }

    Point p = (Point) o;
    return this.x == p.x && this.y = p.y;
  }
}

ColorPoint cp = new ColorPoint(1, 0, Color.RED);
System.out.println(Point.onUnitCircle(cp)); //false 제대로 작동하지 못했음. 기대했던 바는 true
```

- 아래와 같이 바꾸어 좋으면 좋았을 듯

```java
@Override
public boolean equals(Object o) {
  if(o == null || !(o instanceof Point)) {
    return false;
  }

  Point p = (Point) o;
  return this.x == p.x && this.y = p.y;
}
```



##### 상속 대신 컴포지션(Composition)을 사용하라

- 상속 대신에 <u>Point 변수를 갖도록</u> `Composition(구성)`을 이용하는 방법

```java
public ColorPoint {
  private Point point;
  private Color color;

  public ColorPoint(int x, int y, Color color) {
    this.point = new Point(x, y);
    this.color = Objects.requireNonNull(color);
  }

  public Point asPoint() {
    return this.point;
  }

  @Override
  public boolean equals(Object o) {
    if(!(o instanceof ColorPoint)) {
      return false;
    }
    ColorPoint cp = (ColorPoint) o;
    return this.point.equals(cp) && this.color.equals(cp.color); //Point객체의 equals와 Color 객체의 equals를 사용한다.
  }
}
```

- 대칭성, 추이성, 리스코프 치환원칙에 위배되지 않는 코드를 작성할 수 있다.
- 이게 좀 더 나은 방법인듯 한데?



#### 일관성

- 두 객체가 같다면 수정되지 않는 한 **영원히 같아야 함**을 의미

  - 즉 `equals` 를 반복했다고, 결과가 달라져서는 안된다.

- 가변객체의 경우에는 언제 비교하냐에 따라 달라질 수도 있지만, 불변객체는 그래서는 안됨.

  - 하지만 `equals` 비교에는 <u>신뢰할 수 없는 자원이 끼어들어서는 안된다</u>.

  ```java
  RL url1 = new URL("www.site-name.co.kr");
  URL url2 = new URL("www.site-name.co.kr");
  
  System.out.println(url1.equals(url2)); // 매번 다를 수 있음. 항상 같다는 보장을 하지 못한다.
  ```

  

#### Not Null

- 기본적으로 x.equals(null)이 true가 되는 일은 생각하기 어렵다.

```java
@Override 
public boolean equals(Object o) {
  if(o == null) return false; //불필요한 검사다
  return this.x == o.x;
}

@Override
public boolean equals(Object o) {
  if(!(o instanceof MyClass)) return false; //묵시적 null검사, 이쪽이 위 보단 낫다.
  MyClass clazz = (MyClass) o;
  return this.x == clazz.x;
}
```



## 요약 정리

1. `==` 연산자를 사용해 입력된 파라미터와 자기자신이 같은 객체인지 검사한다.
   -  성능 최적화용
   - `equals`는 복잡한 객체 비교용
2. `instanceof` 연산자로 파라미터의 타입이 올바른지 체크
   - 묵시적인 `null` 체크 포함
   - 어떤 인터페이스는 자신을 구현한 서로 다른 클래스끼리도 비교할 수 있도록 `equals` 규약을 수정하기도 함 --> Set, List, Map, Map.Entry

3. 입력을 올바른 타입으로 형변환한다
   - 앞서 2번을 지켰으면 이 단계는 100% 성공
4. 파라미터 `Object` 객체와 자기자신의 대응되는 핵심필드들이 모두 일치하는지 확인
5. `float`,` double`을 제외한 기본타입은 `==`을 통해 비교
6. 참조(reference) 타입은 `equals`를 통해 비교
7. `float`, `double`은` Float.compare(float, float)`와 `Double.compare(double, double)`로 비교한다
   - 왜? Float.Nan, -0.0f등을 비교하기 위함
   - 이 메서드들은 **float -> Float, double -> Double**로 변환하는 <u>오토박싱 기능</u>이 수반되므로 성능상 좋지 못함
8. 배열의 모든 원소가 핵심 필드라면 `Arrays.equals`를 사용하자
9. `null`이 의심되는 필드는` Objects.equals(obj, obj)`를 이용해` NullPointerException`을 예방

10. 비교하기 복잡한 필드인 경우, 필드의 표준형을 지정해놓은 다음, 비교하면 좋음.
    - 불변 클래스로 만들어 놓으면 더 좋다.
11. 비교하는 비용이 싼 필드를 먼저 비교하자



## 주의사항

- `equals`를 다구현했으면 세가지만 자문해보자
  1. 대칭적인가?
  2. 추이성이 있는가?
  3. 일관적인가?
- 자문에서 끝내지말고 테스트도 돌려보자

- ` equals`를 재정의하였으면 `hashCode` 도 반드시 재정의하자
- 너무 복잡하게 생각하지 말자. 최대한 간단하게 필드의 동치성만 비교해도 규약을 지킬 수 있는 경우가 많음.
- `Object` 외 타입을 매개변수로 받는 `equals`를 선언하지는 말자
- AutoValue Framework를 통해 equals 테스트를 대신해보자



## 핵심정리

- 꼭 필요한 경우가 아니면 `equals`를 재정의하지 말자
- 대부분 경우에 개발자가 원하는 방식으로 `equals` 가 작동한다.
- 만약 재정의하면 **5가지 규약**을 모두 지키지는지 확실히 비교해야한다.