## 참고

- https://www.youtube.com/watch?v=Sos11X7wy1M&list=PLVsNizTWUw7FPokuK8Cmlt72DQEt7hKZu


## 목표

- 유투브 강의를 기반으로, 부족했던 `Java` 개념 복습
- 강의 예제 코드를 그대로 써보고 어떻게 돌아가는지 주석 및 `README.md` 파일 갱신


## Chap12
- 멀티 스레드? 
  
    - 하나의 프로세스 안에, 여러개의 스레드가 생성되어서 동시에 코드를 실행하는 것.
    
- main 스레드
    - JVM 에 의해서 생성됨.
    - 다른 스레드들은, main 스레드로 부터 파생된다. 이 말은 제일 처음 생성되는 스레드는 main 스레드.
    
- Thread 를 생성하는 방법은?
    1. Thread class 로 부터
    2. Thread class 하위 클래스로 부터
    - 어떤 차이가 있을까?
    - 1) `Runnable` 인터페이스를 구현하여, Thread 인스턴스를 만들어서, `.start()` 함.
    - 2) `Thread` 객체를 상속받아, extends 통해 확장 구현하는 느낌.
        - 이렇게 상속받았기에, 바로 `start()` 를 실행시킬수 있음.
    
- 메인 스레드 이름은 main
  
    - 작업 스레드는 Thread-n~ 이라고 나옴.
    
- `Thread.currentThread();` 해당 코드를 실행하는 스레드의 참조를 얻는 방법.
  
    - 해당 스레드의 인스턴스를 통해 알수 있겠네
    
- `thread.start()` 는 반드시 한번만 실행할 수 있다.

- 동시성
  - 하나의 코어에서 멀티 스레드가 번갈아가면서 실행하는 성질을 일컫는 말.
  - 한번에 하나의 스레드만 작동한다.
  
- 병렬성
  - 멀티 작업을 위해서 멀티 코어에서 개별 스레드가 동시에 실행하는 성질
  - 한번에 몇몇의 스레드가 실행된다.
  
- 스레드 스케쥴링
  - 왜? 여러개의 스레드가 대기중일 때, 어떻게 번갈아가면서 실행시킬 것인가?를 결정해야하니까
  - 동시성과 관련된 문제.

- 공유객체

  - 두개의 스레드가 하나의 객체를 공유해서 사용할 경우에, 문제가 발생하지 않을까?

- `synchronzied`

  - 단 하나의 메서드만 접근할 수 있는 조건을 선언해주는 방법

  ```java
  public synchronized void method(){
    //단 하나의 스레드만 실행할 수 있는 메서드
  }
  ```

- 스레드

    - Runnable? 실행 대기 상태
    - WAITING, TIME_WAITING, BLOCKED 일시정지 상태
    - NEW 객체가 생성된 상태이고 아직 start가 안되었음.
    - TERMINATED 실행을 마친 상태, 아직 스레드가 닫히진 않았다. 텀이 있음.

- 상태제어

  ![](https://t1.daumcdn.net/cfile/tistory/2135CD42566BC7D825)

  - `stop` 사용하지 말라. 왜? 자원정리가 미미할 수 있다. deprecated된 메서드임.
  - `yield` 다른 스레드에게 실행을 양보할 때 사용됨.
  - `join` 다른 스레드의 종료를 기다린다.

- 스레드간 협업
  - `동기화 메서드(synchronzied)`나, `블록`에서만 호출해야한다. 왜? 한번에 한 스레드만 접근하도록 하려구
  - wait, notify, notifyAll
  - wait 호출한 해당 스레드는 일시정지상태로 감
    - 다른 스레드가 notify or notifyAll을 해야만 일시정지 상태가 풀림
    - 혹은 옵션을 다르게 주던가.
  - 어디에 사용? 공유객체를 여러 스레드에서 접근해야 할때.
  - `Interrupt` 다른 스레들에게 예외를 발생하라고 이야기 해줌. 실행대기 상태로 가라고
    - 다만 InterruptedException이 발생하려면 반드시 해당 스레드는 **일시정지 상태**여야 한다.

- 데몬스레드
  - 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드.
  - ex) GC, 가비지 컬렉터
  - JVM이 실행될때만 가비지 컬렉터가 실행되므로.
  - 주 스레드가 설정하는 것.
    - 반드시 해당 데몬스레드가 실행되기 전에 설정해야 한다.

- 스레드 그룹
  - 어떤 스레드든 하나의 스레드 그룹에 포함된다.
  - 기본적으로는 자신을 생성한 스레드와 같은 그룹에 포함됨.
  - 스레드 그룹을 만들어서, 만든 스레드를 명시적으로 포함시킬 수 있게된다.
  - 특징은,
    - 스레드 그룹에서 interrupt()를 호출하면, 포함된 모든 스레드의 interrupt()가 호출됨.
    - 언제?
    - 스레드 그룹에 있는 모든 스레드를 종료할 필요가 있을때.

- 스레드 풀(ExecutorService)

  - 스레드가 마구마구 뛰어노는 풀장 같은 느낌.
  - ExecutorService의 객체임

  ![](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F231B374B595F67F43A2190)

  - 최대 생성 스레드는, 운영체제 상황에 따라 달라짐.
  - 어떻게 생성되냐에 따라서, 해당 스레드가 종료되더라도 남아있을 수도, 아니면 삭제될 수 도 있네.
  - 스레드 풀의 스레드는 기본적으로 데몬 스레드가 아니므로, **종료** 시켜야한다.
    - `shutdown` 으로
  - 스레드 풀 작업 큐에 들어갈 객체는 `Runnable ` or `Callable` 
    - 차이? 처리 완료 후  `return` 값이 있냐 없냐의 차이
  - 작업을 넣을 때는 `submit`으로 
    - 왜? 해당 스레드를 재사용하므로 좀 더 효율적
  - `submit` 은 `Future` 라는 객체를 리턴 받는다.
    - 왜 Future? 그 즉시 내용을 받음. 아직 스레드에서 처리가 되지 않았는데도 불구하고.
    - 지연되어서 나온다고 해서, *지연객체*라고도 함.
    - 해당 작업이 완료되면 값을 얻기 위해 `get()` 메서드를 사용
    - 블로킹되어있음. 블로킹? 작업이 완료될때까지, 접근할 수 없음.
  - `Future`  `get`은 UI 스레드에서 호출하면 안된다.

